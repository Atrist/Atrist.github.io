# SCSS
- [scss中文文档](https://www.sass.hk/docs/)

Sass 是一款强化 CSS 的辅助工具，它在 CSS 语法的基础上增加了变量 (variables)、嵌套 (nested rules)、混合 (mixins)、导入 (inline imports) 等高级功能，这些拓展令 CSS 更加强大与优雅。使用 Sass 以及 Sass 的样式库（如 Compass）有助于更好地组织管理样式文件，以及更高效地开发项目。

## 1. 特色功能 (Features)
- 完全兼容 CSS3
- 在 CSS 基础上增加变量、嵌套 (nesting)、混合 (mixins) 等功能
- 通过函数进行颜色值与属性值的运算
- 提供控制指令 (control directives)等高级功能
- 自定义输出格式

## 2. 语法格式 (Syntax)
Sass 有两种语法格式。首先是 SCSS (Sassy CSS) —— 也是本文示例所使用的格式 —— 这种格式仅在 CSS3 语法的基础上进行拓展，所有 CSS3 语法在 SCSS 中都是通用的，同时加入 Sass 的特色功能。此外，SCSS 也支持大多数 CSS hacks 写法以及浏览器前缀写法 (vendor-specific syntax)，以及早期的 IE 滤镜写法。这种格式以 .scss 作为拓展名。

另一种也是最早的 Sass 语法格式，被称为缩进格式 (Indented Sass) 通常简称 "Sass"，是一种简化格式。它使用 “缩进” 代替 “花括号” 表示属性属于某个选择器，用 “换行” 代替 “分号” 分隔属性，很多人认为这样做比 SCSS 更容易阅读，书写也更快速。缩进格式也可以使用 Sass 的全部功能，只是与 SCSS 相比个别地方采取了不同的表达方式，具体请查看 `the indented syntax reference`。这种格式以 .sass 作为拓展名。

任何一种格式可以直接 导入 (@import) 到另一种格式中使用，或者通过 `sass-convert` 命令行工具转换成另一种格式：
```js
# Convert Sass to SCSS
$ sass-convert style.sass style.scss

# Convert SCSS to Sass
$ sass-convert style.scss style.sass
```
## 3. CSS 功能拓展 (CSS Extensions)
### 1. 嵌套规则 (Nested Rules)
Sass 允许将一套 CSS 样式嵌套进另一套样式中，内层的样式将它外层的选择器作为父选择器，例如：
```scss
#main p {
  color: #00ff00;
  width: 97%;

  .redbox {
    background-color: #ff0000;
    color: #000000;
  }
}
```
编译为
```scss
#main p {
  color: #00ff00;
  width: 97%; 
}
#main p .redbox {
    background-color: #ff0000;
    color: #000000; 
}
```
嵌套功能避免了重复输入父选择器，而且令复杂的 CSS 结构更易于管理：
```scss
#main {
  width: 97%;

  p, div {
    font-size: 2em;
    a { font-weight: bold; }
  }

  pre { font-size: 3em; }
}
```
编译为
```css
#main {
  width: 97%; 
}
#main p, #main div {
  font-size: 2em; 
}
#main p a, #main div a {
      font-weight: bold; 
}
#main pre {
    font-size: 3em; 
}
```
### 2. 父选择器 & (Referencing Parent Selectors: &)
在嵌套 CSS 规则时，有时也需要直接使用嵌套外层的父选择器，

例如，当给某个元素设定 hover 样式时，或者当 body 元素有某个 classname 时，可以用 & 代表嵌套规则外层的父选择器。

```scss
a {
  font-weight: bold;
  text-decoration: none;
  &:hover { text-decoration: underline; }
  body.firefox & { font-weight: normal; }
}
```
编译为
```css
a {
  font-weight: bold;
  text-decoration: none; }
  a:hover {
    text-decoration: underline; }
  body.firefox a {
    font-weight: normal; }
```
编译后的 CSS 文件中 & 将被替换成嵌套外层的父选择器，如果含有多层嵌套，最外层的父选择器会一层一层向下传递：
```scss
#main {
  color: black;
  a {
    font-weight: bold;
    &:hover { color: red; }
  }
}
```
编译为
```css
#main {
  color: black; }
  #main a {
    font-weight: bold; }
    #main a:hover {
      color: red; }
```
& 必须作为选择器的第一个字符，其后可以跟随后缀生成复合的选择器，例如
```scss
#main {
  color: black;
  &-sidebar { border: 1px solid; }
}
```
编译为
```css
a {
  font-weight: bold;
  text-decoration: none; }
  a:hover {
    text-decoration: underline; }
  body.firefox a {
    font-weight: normal; }
```
当父选择器含有不合适的后缀时，Sass 将会报错。
### 3. 属性嵌套 (Nested Properties)
有些 CSS 属性遵循相同的命名空间 (namespace)，比如 font-family, font-size, font-weight 都以 font 作为属性的命名空间。为了便于管理这样的属性，同时也为了避免了重复输入，Sass 允许将属性嵌套在命名空间中，例如：
```scss
.funky {
  font: {
    family: fantasy;
    size: 30em;
    weight: bold;
  }
}
```
编译为
```css
.funky {
  font-family: fantasy;
  font-size: 30em;
  font-weight: bold; }
```
命名空间也可以包含自己的属性值，例如：
```scss
.funky {
  font: 20px/24px {
    family: fantasy;
    weight: bold;
  }
}
```
编译为
```css
.funky {
  font: 20px/24px;
    font-family: fantasy;
    font-weight: bold; }
```
### 4. 占位符选择器 %foo (Placeholder Selectors: %foo)
Sass 额外提供了一种特殊类型的选择器：占位符选择器 (placeholder selector)。与常用的 id 与 class 选择器写法相似，只是 # 或 . 替换成了 %。


## 4. 注释 /* */ 与 // (Comments: /* */ and //)
Sass 支持标准的 CSS 多行注释 /* */，以及单行注释 //，前者会 被完整输出到编译后的 CSS 文件中，而后者则不会，例如：
```scss
/* This comment is
 * several lines long.
 * since it uses the CSS comment syntax,
 * it will appear in the CSS output. */
body { color: black; }

// These comments are only one line long each.
// They won't appear in the CSS output,
// since they use the single-line comment syntax.
a { color: green; }
```
编译为
```css
/* This comment is
 * several lines long.
 * since it uses the CSS comment syntax,
 * it will appear in the CSS output. */
body {
  color: black; }

a {
  color: green; }
```
将 ! 作为多行注释的第一个字符表示在压缩输出模式下保留这条注释并输出到 CSS 文件中，通常用于添加版权信息。

插值语句 (interpolation) 也可写进多行注释中输出变量值：
```scss
$version: "1.2.3";
/* This CSS is generated by My Snazzy Framework version #{$version}. */
```
编译为
```css
/* This CSS is generated by My Snazzy Framework version 1.2.3. */
```

## 5. SassScript
在 CSS 属性的基础上 Sass 提供了一些名为 SassScript 的新功能。 SassScript 可作用于任何属性，允许属性使用变量、算数运算等额外功能。

通过 interpolation，SassScript 甚至可以生成选择器或属性名，这一点对编写 mixin 有很大帮助。

### 1. Interactive Shell
Interactive Shell 可以在命令行中测试 SassScript 的功能。在命令行中输入 sass -i，然后输入想要测试的 SassScript 查看输出结果：
```bash
$ sass -i
>> "Hello, Sassy World!"
"Hello, Sassy World!"
>> 1px + 1px + 1px
3px
>> #777 + #777
#eeeeee
>> #777 + #888
white
```

### 2. 变量 $ (Variables: $)
SassScript 最普遍的用法就是变量，变量以美元符号开头，赋值方法与 CSS 属性的写法一样：
```scss
$width: 5em;
```
直接使用即调用变量：
```css
#main {
  width: $width;
}
```
变量支持块级作用域，嵌套规则内定义的变量只能在嵌套规则内使用（局部变量），不在嵌套规则内定义的变量则可在任何地方使用（全局变量）。将局部变量转换为全局变量可以添加 !global 声明：
```scss
#main {
  $width: 5em !global;
  width: $width;
}
#sidebar {
  width: $width;
}
```
编译为
```css
#main {
  width: 5em;
}

#sidebar {
  width: 5em;
}
```
### 3. 数据类型 (Data Types)
SassScript 支持 6 种主要的数据类型：
- 数字，1, 2, 13, 10px
- 字符串，有引号字符串与无引号字符串，"foo", 'bar', baz
- 颜色，blue, #04a3f9, rgba(255,0,0,0.5)
- 布尔型，true, false
- 空值，null
- 数组 (list)，用空格或逗号作分隔符，1.5em 1em 0 2em, Helvetica, Arial, sans-serif
- maps, 相当于 JavaScript 的 object，(key1: value1, key2: value2)

SassScript 也支持其他 CSS 属性值，比如 Unicode 字符集，或 !important 声明。然而Sass 不会特殊对待这些属性值，一律视为无引号字符串。

#### 3.1. 字符串 (Strings)
SassScript 支持 CSS 的两种字符串类型：有引号字符串 (quoted strings)，如 "Lucida Grande" 'http://sass-lang.com'；与无引号字符串 (unquoted strings)，如 sans-serif bold，在编译 CSS 文件时不会改变其类型。只有一种情况例外，使用 #{} (interpolation) 时，有引号字符串将被编译为无引号字符串，这样便于在 mixin 中引用选择器名：
```scss
@mixin firefox-message($selector) {
  body.firefox #{$selector}:before {
    content: "Hi, Firefox users!";
  }
}
@include firefox-message(".header");
```
编译为
```css
body.firefox .header:before {
  content: "Hi, Firefox users!"; }
```
#### 3.2. 数组 (Lists)
数组 (lists) 指 Sass 如何处理 CSS 中 `margin: 10px 15px 0 0` 或者 `font-face: Helvetica, Arial, sans-serif` 这样通过空格或者逗号分隔的一系列的值。

事实上，独立的值也被视为数组 —— 只包含一个值的数组。

数组本身没有太多功能，但 [Sass list functions](https://sass-lang.com/documentation/modules#list-functions) 赋予了数组更多新功能：
- nth 函数可以直接访问数组中的某一项；
- join 函数可以将多个数组连接在一起；
- append 函数可以在数组中添加新值；
- @each 指令能够遍历数组中的每一项。

数组中可以包含子数组，比如 `1px 2px, 5px 6px` 是包含 `1px 2px` 与 `5px 6px`两个数组的数组。<br/>如果内外两层数组使用相同的分隔方式，需要用圆括号包裹内层，所以也可以写成 (1px 2px) (5px 6px)。<br/>变化是，之前的 1px 2px, 5px 6px 使用逗号分割了两个子数组 (comma-separated)，而 (1px 2px) (5px 6px) 则使用空格分割(space-separated)。

当数组被编译为 CSS 时，Sass 不会添加任何圆括号（CSS 中没有这种写法），所以 (1px 2px) (5px 6px) 与 1px 2px 5px 6px 在编译后的 CSS 文件中是完全一样的，但是它们在 Sass 文件中却有不同的意义，前者是包含两个数组的数组，而后者是包含四个值的数组。

用 () 表示不包含任何值的空数组（在 Sass 3.3 版之后也视为空的 map）。空数组不可以直接编译成 CSS，比如编译 font-family: () Sass 将会报错。<br/>
如果数组中包含空数组或空值，编译时将被清除，比如 1px 2px () 3px 或 1px 2px null 3px。

基于逗号分隔的数组允许保留结尾的逗号，这样做的意义是强调数组的结构关系，尤其是需要声明只包含单个值的数组时。例如 (1,) 表示只包含 1 的数组，而 (1 2 3,) 表示包含 1 2 3 这个以空格分隔的数组的数组。

#### 3.3. Maps
Maps可视为键值对的集合，键被用于定位值 在css种没有对应的概念。 和Lists不同Maps必须被圆括号包围，键值对被都好分割 。

 Maps中的keys和values可以是sassscript的任何对象。（包括任意的sassscript表达式 arbitrary SassScript expressions） 和Lists一样Maps主要为sassscript函数服务，如 map-get函数用于查找键值，map-merge函数用于map和新加的键值融合，@each命令可添加样式到一个map中的每个键值对。 
 
 Maps可用于任何Lists可用的地方，在List函数中 Map会被自动转换为List ， 如 (key1: value1, key2: value2)会被List函数转换为 key1 value1, key2 value2 ，反之则不能。

 #### 3.4. 颜色 (Colors)
 任何CSS颜色表达式都将返回SassScript颜色值,这包括大量与未引用的字符串无法区分的命名颜色.在压缩输出模式下，Sass将输出颜色的最小CSS表示.
例如，＃FF0000在压缩模式下将输出为红色，但是blanchedalmond将输出为#FFEBCD。用户使用命名颜色时遇到的一个常见问题是，由于Sass希望使用与在其他输出模式中键入的输出格式相同的输出格式，因此插值到选择器中的颜色在压缩时将变为无效语法。为避免这种情况，如果要在选择器的构造中使用命名颜色，请始终引用这些颜色。

### 4. 运算 (Operations)
所有数据类型均支持相等运算 == 或 !=，此外，每种数据类型也有其各自支持的运算方式。
#### 4.1. 数字运算 (Number Operations)
SassScript 支持数字的加减乘除、取整等运算 (+, -, *, /, %)，如果必要会在不同单位间转换值。
```scss
p {
  width: 1in + 8pt;
}
```
编译为
```css
p {
  width: 1.111in; }
```
关系运算 <, >, <=, >= 也可用于数字运算，相等运算 ==, != 可用于所有数据类型。
##### 1.1. 除法运算 / (Division and /)
/ 在 CSS 中通常起到分隔数字的用途，SassScript 作为 CSS 语言的拓展当然也支持这个功能，同时也赋予了 / 除法运算的功能。也就是说，如果 / 在 SassScript 中把两个数字分隔，编译后的 CSS 文件中也是同样的作用。

以下三种情况 / 将被视为除法运算符号：
- 如果值，或值的一部分，是变量或者函数的返回值
- 如果值被圆括号包裹
- 如果值是算数表达式的一部分
```scss
p {
  font: 10px/8px;             // Plain CSS, no division
  $width: 1000px;
  width: $width/2;            // Uses a variable, does division
  width: round(1.5)/2;        // Uses a function, does division
  height: (500px/2);          // Uses parentheses, does division
  margin-left: 5px + 8px/2px; // Uses +, does division
}
```
编译为
```css
p {
  font: 10px/8px;
  width: 500px;
  height: 250px;
  margin-left: 9px; 
}
```
如果需要使用变量，同时又要确保 / 不做除法运算而是完整地编译到 CSS 文件中，只需要用 #{} 插值语句将变量包裹。
```scss
p {
  $font-size: 12px;
  $line-height: 30px;
  font: #{$font-size}/#{$line-height};
}
```
编译为
```css
p {
  font: 12px/30px; }
```
#### 4.2. 颜色值运算 (Color Operations)
颜色值的运算是分段计算进行的，也就是分别计算红色，绿色，以及蓝色的值：
```scss
p {
  color: #010203 + #040506;
}
```
计算 `01 + 04 = 05 | 02 + 05 = 07 | 03 + 06 = 09`，然后编译为
```css
p {
  color: #050709; }
```
使用 [color functions](https://sass-lang.com/documentation/modules) 比计算颜色值更方便一些。

数字与颜色值之间也可以进行算数运算，同样也是分段计算的，比如
```scss
p {
  color: #010203 * 2;
}
```
计算 `01 * 2 = 02 | 02 * 2 = 04 | 03 * 2 = 06`，然后编译为
```css
p {
  color: #020406; }
```
需要注意的是，如果颜色值包含 alpha channel（rgba 或 hsla 两种颜色值），必须拥有相等的 alpha 值才能进行运算，因为算术运算不会作用于 alpha 值。
```scss
p {
  color: rgba(255, 0, 0, 0.75) + rgba(0, 255, 0, 0.75);
}
```
编译为
```css
p {
  color: rgba(255, 255, 0, 0.75); }
```
颜色值的 alpha channel 可以通过 [opacify](https://sass-lang.com/documentation/modules/color#opacify) 或 [transparentize](https://sass-lang.com/documentation/modules/color#transparentize) 两个函数进行调整。

```scss
$translucent-red: rgba(255, 0, 0, 0.5);
p {
  color: opacify($translucent-red, 0.3);
  background-color: transparentize($translucent-red, 0.25);
}
```
编译为
```css
p {
  color: rgba(255, 0, 0, 0.8);
  background-color: rgba(255, 0, 0, 0.25); }
```
IE 滤镜要求所有的颜色值包含 alpha 层，而且格式必须固定 #AABBCCDD，使用 ie_hex_str 函数可以很容易地将颜色转化为 IE 滤镜要求的格式。
```scss
$translucent-red: rgba(255, 0, 0, 0.5);
$green: #00ff00;
div {
  filter: progid:DXImageTransform.Microsoft.gradient(enabled='false', startColorstr='#{ie-hex-str($green)}', endColorstr='#{ie-hex-str($translucent-red)}');
}
```
编译为
```css
div {
  filter: progid:DXImageTransform.Microsoft.gradient(enabled='false', startColorstr=#FF00FF00, endColorstr=#80FF0000);
}
```
#### 4.3. 字符串运算 (String Operations)
`+` 可用于连接字符串
```scss
p {
  cursor: e + -resize;
}
```
编译为
```css
p {
  cursor: e-resize; }
```
注意，如果有引号字符串（位于 + 左侧）连接无引号字符串，运算结果是有引号的，相反，无引号字符串（位于 + 左侧）连接有引号字符串，运算结果则没有引号。
```scss
p:before {
  content: "Foo " + Bar;
  font-family: sans- + "serif";
}
```
编译为
```css
p:before {
  content: "Foo Bar";
  font-family: sans-serif; }
```
运算表达式与其他值连用时，用空格做连接符：
```scss
p {
  margin: 3px + 4px auto;
}
```
编译为
```css
p {
  margin: 7px auto; }
```
在有引号的文本字符串中使用 #{} 插值语句可以添加动态的值：
```scss
p:before {
  content: "I ate #{5 + 10} pies!";
}
```
编译为
```css
p:before {
  content: "I ate 15 pies!"; }
```
空的值被视作插入了空字符串：
```scss
$value: null;
p:before {
  content: "I ate #{$value} pies!";
}
```
编译为
```css
p:before {
  content: "I ate pies!"; }
```
#### 4.4. 布尔运算 (Boolean Operations)
SassScript 支持布尔型的 and or 以及 not 运算。
#### 4.5. 数组运算 (List Operations)
数组不支持任何运算方式，只能使用 [list functions](https://sass-lang.com/documentation/modules#list-functions) 控制。

### 5. 圆括号 (Parentheses)
圆括号可以用来影响运算的顺序：
```scss
p {
  width: 1em + (2em * 3);
}
```
编译为
```css
p {
  width: 7em; }
```
### 6. 函数 (Functions)
SassScript 定义了多种函数，有些甚至可以通过普通的 CSS 语句调用：
```scss
p {
  color: hsl(0, 100%, 50%);
}
```
编译为
```css
p {
  color: #ff0000; }
```
#### 6.1. 关键词参数 (Keyword Arguments)
Sass 函数允许使用关键词参数 (keyword arguments)，上面的例子也可以写成：
```scss
p {
  color: hsl($hue: 0, $saturation: 100%, $lightness: 50%);
}
```
虽然不够简明，但是阅读起来会更方便。关键词参数给函数提供了更灵活的接口，以及容易调用的参数。关键词参数可以打乱顺序使用，如果使用默认值也可以省缺，另外，参数名被视为变量名，下划线、短横线可以互换使用。

通过 [Sass::Script::Functions](https://sass-lang.com/documentation/modules) 查看完整的 Sass 函数列表，参数名，以及如何自定义函数。

### 7. 插值语句 #{} (Interpolation: #{})
通过 #{} 插值语句可以在选择器或属性名中使用变量：
```scss
$name: foo;
$attr: border;
p.#{$name} {
  #{$attr}-color: blue;
}
```
编译为
```css
p.foo {
  border-color: blue; }
```
`#{}` 插值语句也可以在属性值中插入 SassScript，大多数情况下，这样可能还不如使用变量方便，但是使用 `#{}` 可以避免 Sass 运行运算表达式，直接编译 CSS。
```scss
p {
  $font-size: 12px;
  $line-height: 30px;
  font: #{$font-size}/#{$line-height};
}
```
编译为
```css
p {
  font: 12px/30px; }
```
### 8. `&` in SassScript
就像在选择器中使用时一样，＆在SassScript中是指当前的父选择器。这是一个用逗号分隔的列表，以空格分隔。例如：
```scss
.foo.bar .baz.bang, .bip.qux {
  $selector: &;
}
```
$selector的值现在是（（“ .foo.bar”“ .baz.bang”），“ .bip.qux”）。复合选择器在这里用引号引起来表示它们是字符串，但实际上它们将不带引号。

即使父选择器不包含逗号或空格，＆也会始终具有两个嵌套级别，因此可以一致地对其进行访问。

如果没有父选择器，则＆的值为空。这意味着您可以在mixin中使用它来检测是否存在父选择器：
```scss
@mixin does-parent-exist {
  @if & {
    &:hover {
      color: red;
    }
  } @else {
    a {
      color: red;
    }
  }
}
```
### 9. 变量定义 !default (Variable Defaults: !default)
可以在变量的结尾添加 !default 给一个未通过 !default 声明赋值的变量赋值，此时，如果变量已经被赋值，不会再被重新赋值，但是如果变量还没有被赋值，则会被赋予新的值。
```scss
$content: "First content";
$content: "Second content?" !default;
$new_content: "First time reference" !default;

#main {
  content: $content;
  new-content: $new_content;
}
```
编译为
```css
#main {
  content: "First content";
  new-content: "First time reference"; }
```
变量是 null 空值时将视为未被 !default 赋值。
```scss
$content: null;
$content: "Non-null content" !default;

#main {
  content: $content;
}
```
编译为
```css
#main {
  content: "Non-null content"; }
```
## 6. @-Rules 与指令 (@-Rules and Directives)
Sass 支持所有的 CSS3 @-Rules，以及 Sass 特有的 “指令”（directives）。这一节会详细解释，更多资料请查看 控制指令 (control directives) 与 混合指令 (mixin directives) 两个部分。
### 1. @import
Sass 拓展了 `@import` 的功能，允许其导入 SCSS 或 Sass 文件。被导入的文件将合并编译到同一个 CSS 文件中，另外，被导入的文件中所包含的变量或者混合指令 (mixin) 都可以在导入的文件中使用。

Sass 在当前地址，或 Rack, Rails, Merb 的 Sass 文件地址寻找 Sass 文件，如果需要设定其他地址，可以用 `:load_paths` 选项，或者在命令行中输入 `--load-path` 命令。

通常，@import 寻找 Sass 文件并将其导入，但在以下情况下，@import 仅作为普通的 CSS 语句，不会导入任何 Sass 文件。
- 文件拓展名是 .css；
- 文件名以 http:// 开头；
- 文件名是 url()；
- @import 包含 media queries。

如果不在上述情况内，文件的拓展名是 .scss 或 .sass，则导入成功。没有指定拓展名，Sass 将会试着寻找文件名相同，拓展名为 .scss 或 .sass 的文件并将其导入。
```scss
@import "foo.scss";
```
或
```scss
@import "foo";
```
都会导入文件 foo.scss，但是
```scss
@import "foo.css";
@import "foo" screen;
@import "http://foo.com/bar";
@import url(foo);
```
编译为
```css
@import "foo.css";
@import "foo" screen;
@import "http://foo.com/bar";
@import url(foo);
```
Sass 允许同时导入多个文件，例如同时导入 rounded-corners 与 text-shadow 两个文件：
```scss
@import "rounded-corners", "text-shadow";
```
导入文件也可以使用 #{ } 插值语句，但不是通过变量动态导入 Sass 文件，只能作用于 CSS 的 url() 导入方式：
```css
$family: unquote("Droid+Sans");
@import url("http://fonts.googleapis.com/css?family=\#{$family}"); 
h
```
编译为
```css
@import url("http://fonts.googleapis.com/css?family=Droid+Sans");
```
#### 1.1. 分音 (Partials)
如果需要导入 SCSS 或者 Sass 文件，但又不希望将其编译为 CSS，只需要在文件名前添加下划线，这样会告诉 Sass 不要编译这些文件，但导入语句中却不需要添加下划线。

例如，将文件命名为 _colors.scss，便不会编译 _colours.css 文件。
```scss
@import "colors";
```
上面的例子，导入的其实是 _colors.scss 文件

注意，不可以同时存在添加下划线与未添加下划线的同名文件，添加下划线的文件将会被忽略。

#### 1.2. 嵌套 @import
大多数情况下，一般在文件的最外层（不在嵌套规则内）使用 @import，其实，也可以将 @import 嵌套进 CSS 样式或者 @media 中，与平时的用法效果相同，只是这样导入的样式只能出现在嵌套的层中。

假设 example.scss 文件包含以下样式：
```scss
.example {
  color: red;
}
```
然后导入到 #main 样式内
```scss
#main {
  @import "example";
}
```
将会被编译为
```css
#main .example {
  color: red;
}
```
不可以在混合指令 (mixin) 或控制指令 (control directives) 中嵌套 @import。

### 2. @media
Sass 中 @media 指令与 CSS 中用法一样，只是增加了一点额外的功能：允许其在 CSS 规则中嵌套。如果 @media 嵌套在 CSS 规则内，编译时，@media 将被编译到文件的最外层，包含嵌套的父选择器。这个功能让 @media 用起来更方便，不需要重复使用选择器，也不会打乱 CSS 的书写流程。

```scss
.sidebar {
  width: 300px;
  @media screen and (orientation: landscape) {
    width: 500px;
  }
}
```
编译为
```css
.sidebar {
  width: 300px; }
  @media screen and (orientation: landscape) {
    .sidebar {
      width: 500px; } } 
```
@media 的 queries 允许互相嵌套使用，编译时，Sass 自动添加 and
```scss
@media screen {
  .sidebar {
    @media (orientation: landscape) {
      width: 500px;
    }
  }
}
```
编译为
```css
@media screen and (orientation: landscape) {
  .sidebar {
    width: 500px; } }
```
@media 甚至可以使用 SassScript（比如变量，函数，以及运算符）代替条件的名称或者值：
```scss
$media: screen;
$feature: -webkit-min-device-pixel-ratio;
$value: 1.5;

@media #{$media} and ($feature: $value) {
  .sidebar {
    width: 500px;
  }
}
```
编译为
```css
@media screen and (-webkit-min-device-pixel-ratio: 1.5) {
  .sidebar {
    width: 500px; } }
```
### 3. @extend
在设计网页的时候常常遇到这种情况：一个元素使用的样式与另一个元素完全相同，但又添加了额外的样式。通常会在 HTML 中给元素定义两个 class，一个通用样式，一个特殊样式。假设现在要设计一个普通错误样式与一个严重错误样式，一般会这样写：
```scss
<div class="error seriousError">
  Oh no! You've been hacked!
</div>
```
样式如下
```css
.error {
  border: 1px #f00;
  background-color: #fdd;
}
.seriousError {
  border-width: 3px;
}
```
麻烦的是，这样做必须时刻记住使用 .seriousError 时需要参考 .error 的样式，带来了很多不变：智能比如加重维护负担，导致 bug，或者给 HTML 添加无语意的样式。使用 @extend 可以避免上述情况，告诉 Sass 将一个选择器下的所有样式继承给另一个选择器。
```scss
.error {
  border: 1px #f00;
  background-color: #fdd;
}
.seriousError {
  @extend .error;
  border-width: 3px;
}
```
上面代码的意思是将 `.error` 下的所有样式继承给 `.seriousError`，`border-width: 3px`; 是单独给 `.seriousError` 设定特殊样式，这样，使用 `.seriousError` 的地方可以不再使用 `.error`。

其他使用到 `.error` 的样式也会同样继承给 `.seriousError`，例如，另一个样式 `.error.intrusion` 使用了 `hacked.png` 做背景，`<div class="seriousError intrusion">` 也同样会使用 `hacked.png` 背景。
```css
.error.intrusion {
  background-image: url("/image/hacked.png");
}
```
#### 3.1. How it Works
`@extend` 的作用是将重复使用的样式 (`.error`) 延伸 (extend) 给需要包含这个样式的特殊样式（`.seriousError`），刚刚的例子：
```scss
.error {
  border: 1px #f00;
  background-color: #fdd;
}
.error.intrusion {
  background-image: url("/image/hacked.png");
}
.seriousError {
  @extend .error;
  border-width: 3px;
}
```
编译为
```css
.error, .seriousError {
  border: 1px #f00;
  background-color: #fdd; }

.error.intrusion, .seriousError.intrusion {
  background-image: url("/image/hacked.png"); }

.seriousError {
  border-width: 3px; }
```
当合并选择器时，`@extend` 会很聪明地避免无谓的重复，`.seriousError.seriousError` 将编译为 `.seriousError`，不能匹配任何元素的选择器（比如 `#main#footer` ）也会删除。

#### 3.2. 延伸复杂的选择器 (Extending Complex Selectors)
Class 选择器并不是唯一可以被延伸 (extend) 的，Sass 允许延伸任何定义给单个元素的选择器，比如 `.special.cool`，`a:hover` 或者 `a.user[href^="http://"]` 等，例如：
```scss
.hoverlink {
  @extend a:hover;
}
```
同 class 元素一样，`a:hover` 的样式将继承给 `.hoverlink`。
```css
.hoverlink {
  @extend a:hover;
}
a:hover {
  text-decoration: underline;
}
```
编译为
```css
a:hover, .hoverlink {
  text-decoration: underline; }
```
与上面 `.error.intrusion` 的例子一样，所有 `a:hover` 的样式将继承给 `.hoverlink`，包括其他使用到 `a:hover` 的样式，例如：
```css
.hoverlink {
  @extend a:hover;
}
.comment a.user:hover {
  font-weight: bold;
}
```
