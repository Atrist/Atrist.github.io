# 模式（Patterns）和修饰符（flags）
正则表达式是搜索和替换字符串的一种强大方式。

在 JavaScript 中，正则表达式通过内置的“RegExp”类的对象来实现，并与字符串集成。

请注意，在各编程语言之间，正则表达式是有所不同的。在本教程中，我们只专注于 JavaScript。当然，它们有很多共同点，但在 Perl、Ruby 和 PHP 等语言下会有所不同。
## 正则表达式
正则表达式（可叫作“regexp”或者“reg”）包含 模式 和可选的 修饰符。

创建一个正则表达式对象有两种语法。

较长一点的语法：
```js
regexp = new RegExp("pattern", "flags");
```
…较短一点的语法，使用斜杠 "/"：
```js
regexp = /pattern/; // 没有修饰符
regexp = /pattern/gmi; // 伴随修饰符 g、m 和 i（后面会讲到）
```
斜杠 "/" 会告诉 JavaScript 我们正在创建一个正则表达式。它的作用类似于字符串的引号。

## 用法
如果要在字符串中进行搜索，可以使用 [search](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/String/search) 方法。

下面是示例：
```js
let str = "I love JavaScript!"; // 将在这里搜索

let regexp = /love/;
alert( str.search(regexp) ); // 2
```
`str.search` 方法会查找模式 `/love/`，然后返回匹配项在字符串中的位置。我们可以猜到，`/love/` 是最简单的模式。它所做的就是简单的子字符串的查找。

上面的代码等同于：
```js
let str = "I love JavaScript!"; // 将在这里搜索

let substr = 'love';
alert( str.search(substr) ); // 2
```
所以搜索 `/love/` 与搜索 `"love"` 是等价的。

但这只是暂时的。很快我们就会接触更复杂的正则表达式，其搜索功能将更强大。

>:information_source: 

什么时候使用 new RegExp?

通常我们使用的都是简短语法 `/.../`。但是它不接受任何变量插入，所以我们必须在写代码的时候就知道确切的 regexp。

另一方面，`new RegExp` 允许从字符串中动态地构造模式。

所以我们可以找出需要搜索的字段，然后根据搜索字段创建 `new RegExp`：
```js
let search = prompt("What you want to search?", "love");
let regexp = new RegExp(search);

// 找到用户想要的任何东西
alert( "I love JavaScript".search(regexp));
```
## 修饰符
正则表达式的修饰符可能会影响搜索结果。

在 JavaScript 中，有 5 个修饰符：

`i`<br/>
使用此修饰符后，搜索时不区分大小写: A 和 a 没有区别（具体看下面的例子）。

`g`<br/>
使用此修饰符后，搜索时会查找所有的匹配项，而不只是第一个（在下一章会讲到）。

`m`<br/>
多行模式（详见章节 文章 "regexp-multiline" 未找到）。

`u`<br/>
开启完整的 unicode 支持。该修饰符能够修正对于代理对的处理。更详细的内容见章节 Unicode：修饰符 “u” 和 class \p{...}。

`y`<br/>
粘滞模式（详见 下一章节）

## “i”修饰符
最简单的修饰符就是 i 了。

示例代码如下：
```js
let str = "I love JavaScript!";

alert( str.search(/LOVE/) ); // -1（没找到）
alert( str.search(/LOVE/i) ); // 2
```
1. 第一个搜索返回的是 `-1`（也就是没找到），因为搜索默认是区分大小写的。
2. 使用修饰符 `/LOVE/i`，在字符串的第 `2` 个位置上搜索到了 `love`。
相比与简单的子字符串查找，i 修饰符已经让正则表达式变得更加强大了。但是这还不够。我们会在下一章节讲述其它修饰符和特性。

## 总结
- 一个正则表达式包含模式和可选修饰符：`g`、`i`、`m`、`u`、`y`。
- 如果不使用我们在后面将要学到的修饰符和特殊标志，正则表达式的搜索就等同于子字符串查找。
- str.search(regexp) 方法返回的是找到的匹配项的索引位置，如果没找到则返回 -1。

# 字符类
考虑一个实际的任务 – 我们有一个电话号码，例如 "+7(903)-123-45-67"，我们需要将其转换为纯数字：79035419441。

为此，我们可以查找并删除所有非数字的内容。字符类可以帮助解决这个问题。

**字符类（Character classes）** 是一个特殊的符号，匹配特定集中的任何符号。

首先，让我们探索“数字”类。它写为 `\d`，对应于“任何一个数字”。

例如，让我们找到电话号码的第一个数字：
```js
let str = "+7(903)-123-45-67";

let regexp = /\d/;

alert( str.match(regexp) ); // 7
```
如果没有标志 `g`，则正则表达式仅查找第一个匹配项，即第一个数字 `\d`。

让我们添加 `g`标志来查找所有数字：
```js
let str = "+7(903)-123-45-67";

let regexp = /\d/g;

alert( str.match(regexp) ); // array of matches: 7,9,0,3,1,2,3,4,5,6,7

// let's make the digits-only phone number of them:
alert( str.match(regexp).join('') ); // 79035419441
```
这是数字的字符类。还有其他字符类。

最常用的是：

**`\d`（“d” 来自 “digit”）**<br/>
数字：从 0 到 9 的字符。

**`\s`（“s” 来自 “space”）**<br/>
空格符号：包括空格，制表符 \t，换行符 \n 和其他少数稀有字符，例如 \v，\f 和 \r。

**`\w`（“w” 来自 “word”）**<br/>
“单字”字符：拉丁字母或数字或下划线 _。非拉丁字母（如西里尔字母或印地文）不属于 \w。

例如，`\d\s\w`表示“数字”，后跟“空格字符”，后跟“单字字符”，例如 `1 a`。

**正则表达式可能同时包含常规符号和字符类。**

例如，`CSS\d` 匹配字符串 `CSS `与后面的数字：
```js
let str = "Is there CSS4?";
let regexp = /CSS\d/

alert( str.match(regexp) ); // CSS4
```
我们还可以使用许多字符类：
```js
alert( "I love HTML5!".match(/\s\w\w\w\w\d/) ); // ' HTML5'
```
匹配项（每个正则表达式字符类都有对应的结果字符）：

![](https://zh.javascript.info/article/regexp-character-classes/love-html5-classes.svg)

## 反向类
对于每个字符类，都有一个“反向类”，用相同的字母表示，但要以大写书写形式。

“反向”表示它与所有其他字符匹配，例如：
`\D`<br/>
非数字：除 `\d` 以外的任何字符，例如字母。

`\S`<br/>
非空格符号：除 `\s` 以外的任何字符，例如字母。

`\W`<br/>
非单字字符：除 \w 以外的任何字符，例如非拉丁字母或空格。

在这一章的开头，我们看到了如何从 `+7(903)-123-45-67` 这样的字符串中创建一个只包含数字的电话号码: 找到所有的数字并将它们连接起来。
```js
let str = "+7(903)-123-45-67";

alert( str.match(/\d/g).join('') ); // 79031234567
```
另一种快捷的替代方法是查找非数字 `\D `并将其从字符串中删除：
```js
let str = "+7(903)-123-45-67";

alert( str.replace(/\D/g, "") ); // 79031234567
```
## 点（.）是匹配“任何字符”

点 `.` 是一种特殊字符类，它与 “除换行符之外的任何字符” 匹配。

例如：
```js
alert( "Z".match(/./) ); // Z
```
或在正则表达式中间：
```js
let regexp = /CS.4/;

alert( "CSS4".match(regexp) ); // CSS4
alert( "CS-4".match(regexp) ); // CS-4
alert( "CS 4".match(regexp) ); // CS 4 (space is also a character)
```
请注意，点表示“任何字符”，而不是“缺少字符”。必须有一个与之匹配的字符：
```js
alert( "CS4".match(/CS.4/) ); // null, no match because there's no character for the dot
```
### 带有“s”标志时点字符类严格匹配任何字符
默认情况下，点与换行符 `\n` 不匹配。

例如，正则表达式 `A.B` 匹配 `A`，然后匹配 `B` 和它们之间的任何字符，除了换行符`\n`：
```js
alert( "A\nB".match(/A.B/) ); // null (no match)
```
在许多情况下，当我们希望用点来表示“任何字符”（包括换行符）时。

这就是标志 `s` 所做的。如果有一个正则表达式，则点 `.` 实际上匹配任
```js
alert( "A\nB".match(/A.B/s) ); // A\nB (match!)
```
>:warning:  不支持 Firefox、IE、Edge

使用前可从 https://caniuse.com/#search=dotall 确认以获得最新的支持状态。在撰写本文时，它不包括 Firefox、IE、Edge。

幸运的是，有一种替代方法可以在任何地方使用。我们可以使用诸如 `[\s\S]` 之类的正则表达式来匹配“任何字符”。
```js
alert( "A\nB".match(/A[\s\S]B/) ); // A\nB (match!)
```
模式 `[\s\S]` 从字面上说：“空格字符或非空格字符”。换句话说，“任何东西”。我们可以使用另一对互补的类，例如 `[\d\D]`。甚至是 `[^]` —— 意思是匹配任何字符，除了什么都没有。

如果我们希望两种“点”都使用相同的模式，也可以使用此技巧：实际的点 . 具有常规方式（“不包括换行符”）以及一种使用 `[\s\S]` 或类似形式匹配“任何字符”。
>:warning: 注意空格

通常我们很少注意空格。对我们来说，字符串 1-5 和 1 - 5 几乎相同。

但是，如果正则表达式未考虑空格，则可能无法正常工作。

让我们尝试查找由连字符（-）分隔的数字：
```js
alert( "1 - 5".match(/\d-\d/) ); // null, no match!
```
让我们修复一下，在正则表达式中添加空格：\ d-\ d`：
```js
alert( "1 - 5".match(/\d - \d/) ); // 1 - 5, now it works
// or we can use \s class:
alert( "1 - 5".match(/\d\s-\s\d/) ); // 1 - 5, also works
```
**空格是一个字符。与其他字符同等重要。**

我们无法在正则表达式中添加或删除空格，并且期望能正常工作。

换句话说，在正则表达式中，所有字符都很重要，空格也很重要。

## 总结
存在以下字符类：

- `\d` —— 数字。
- `\D` —— 非数字。
- `\s` —— 空格符号，制表符，换行符。
- `\S` —— 除了 `\s` 。
- `\w` —— 拉丁字母，数字，下划线 `'_'`。
- `\W` —— 除了 `\w`。
- `.`—— 任何带有 `'s'` 标志的字符，否则为除换行符 `\n`之外的任何字符。

……但这还不是全部！

JavaScript 用于字符串的 Unicode 编码提供了许多字符属性，例如：这个字母属于哪一种语言（如果它是一个字母）？它是标点符号吗？等等。

我们也可以通过这些属性进行搜索。这需要标志 `u`，在下一篇文章中介绍。
# Unicode：修饰符 “u” 和 class \p{...}
JavaScript 使用 [Unicode](https://en.wikipedia.org/wiki/Unicode) 编码 （Unicode encoding）对字符串进行编码。大多数字符使用 2 个字节编码，但这种方式只能编码最多 65536 个字符。

这个范围不足以对所有可能的字符进行编码，这就是为什么一些罕见的字符使用 4 个字节进行编码，比如 𝒳 （数学符号 X）或者 😄 （笑脸），一些象形文字等等。

以下是一些字符对应的 unicode 编码


字符	|Unicode	|unicode 中的字节数
--|--|--
a	|0x0061	|2
≈	|0x2248	|2
𝒳	|0x1d4b3	|4
𝒴	|0x1d4b4	|4
😄	|0x1f604	|4

所以像 a 和 ≈ 这样的字符占用 2 个字节，而 𝒳，𝒴 和 😄 的对应编码则更长，它们具有 4 个字节的长度。

很久以前，当 JavaScript 被发明出来的时候，Unicode 的编码要更加简单：当时并没有 4 个字节长的字符。所以，一部分语言特性在现在仍旧无法对 unicode 进行正确的处理。

比如 length 认为这里的输入有 2 个字符：
```js
alert('😄'.length); // 2
alert('𝒳'.length); // 2
```
…但我们可以清楚地认识到输入的字符只有一个，对吧？关键在于 `length` 把 4 个字节当成了 2 个 2 字节长的字符。这是不对的，因为它们必须被当作一个整体来考虑。（即所谓的“代理伪字符”（surrogate pair），你可以在这里进一步阅读有关的的信息 字符串）。

默认情况下，正则表达式同样把一个 4 个字节的“长字符”当成一对 2 个字节长的字符。正如在字符串中遇到的情况，这将导致一些奇怪的结果。我们将很快在后面的文章中遇到 [集合和范围 [...]](https://zh.javascript.info/regexp-character-sets-and-ranges)。

与字符串有所不同的是，正则表达式有一个修饰符 `u` 被用以解决此类问题。当一个正则表达式使用这个修饰符后，4 个字节长的字符将被正确地处理。同时也能够用上 Unicode 属性（Unicode property）来进行查找了。我们接下来就来了解这方面的内容。

## Unicode 属性（Unicode properties）\p{…}
>:warning: **在 Firefox 和 Edge 中缺乏支持**

尽管 unicode property 从 2018 年以来便作为标准的一部分, 但 unicode 属性在 Firefox ([bug](https://bugzilla.mozilla.org/show_bug.cgi?id=1361876)) 和 Edge ([bug](https://github.com/Microsoft/ChakraCore/issues/2969)) 中并没有相应的支持。

目前 [XRegExp](http://xregexp.com/) 这个库提供“扩展”的正则表达式，其中包括对 unicode property 的跨平台支持。


Unicode 中的每一个字符都具有很多的属性。它们描述了一个字符属于哪个“类别”，包含了各种关于字符的信息。

例如，如果一个字符具有 Letter 属性，这意味着这个字符归属于（任意语言的）一个字母表。而 Number 属性则表示这是一个数字：也许是阿拉伯语，亦或者是中文，等等。

我们可以查找具有某种属性的字符，写作 `\p{…}`。为了顺利使用 `\p{…}`，一个正则表达式必须使用修饰符 `u`。

举个例子，`\p{Letter}` 表示任何语言中的一个字母。我们也可以使用 `\p{L}`，因为 `L` 是 Letter 的一个别名（alias）。对于每种属性而言，几乎都存在对应的缩写别名。

在下面的例子中 3 种字母将会被查找出：英语、格鲁吉亚语和韩语。
```js
let str = "A ბ ㄱ";

alert( str.match(/\p{L}/gu) ); // A,ბ,ㄱ
alert( str.match(/\p{L}/g) ); // null（没有匹配的文本，因为没有修饰符“u”）
```
以下是主要的字符类别和它们对应的子类别：
- 字母（Letter） L:
  - 小写（lowercase） Ll
  - 修饰（modifier） Lm,
  - 首字母大写（titlecase） Lt,
  - 大写（uppercase） Lu,
  - 其它（other） Lo。
- 数字（Number） N:
  - 十进制数字（decimal digit） Nd,
  - 字母数字（letter number） Nl,
  - 其它（other） No。
- 标点符号（Punctuation） P:
  - 链接符（connector） Pc,
  - 横杠（dash） Pd,
  - 起始引用号（initial quote） Pi,
  - 结束引用号（final quote） Pf,
  - 开（open） Ps,
  - 闭（close） Pe,
  - 其它（other） Po。
- 标记（Mark） M (accents etc):
  - 间隔合并（spacing combining） Mc,
  - 封闭（enclosing） Me,
  - 非间隔（non-spacing） Mn。
  - 符号（Symbol） S:
  - 货币（currency） Sc,
  - 修饰（modifier） Sk,
  - 数学（math） Sm,
  - 其它（other） So。
- 分隔符（Separator） Z:
  - 行（line） Zl,
  - 段落（paragraph） Zp,
  - 空格（space） Zs。
- 其它（Other） C:
  - 控制符（control） Cc,
  - 格式（format） Cf,
  - 未分配（not assigned） Cn,
  - 私有（private use） Co,
  - 代理伪字符（surrogate） Cs。

因此，比如说我们需要小写的字母，就可以写成 `\p{Ll}`，标点符号写作 `\p{P}` 等等。

也有其它派生的类别，例如：

- `Alphabetic (Alpha)`, 包含了字母 L, 加上字母数字 Nl （例如 Ⅻ – 罗马数字 12），加上一些其它符号 `Other_Alphabetic (OAlpha)`。
- `Hex_Digit` 包括 16 进制数字 0-9，a-f。
- …等等

Unicode 支持相当数量的属性，列出整个清单需要占用大量的空间，因此在这里列出相关的链接：

- 列出一个字符的所有属性 https://unicode.org/cldr/utility/character.jsp.
- 按照属性列出所有的字符 https://unicode.org/cldr/utility/list-unicodeset.jsp.
- 属性的对应缩写形式：https://www.unicode.org/Public/UCD/latest/ucd/PropertyValueAliases.txt.
- 以文本格式整理的所有 Unicode 字符，包含了所有的属性：https://www.unicode.org/Public/UCD/latest/ucd/.

### 实例：16 进制数字
举个例子，让我们来查找 16 进制数字，写作 xFF 其中 F 是一个 16 进制的数字（0…1 或者 A…F）。

一个 16 进制数字可以表示为 `\p{Hex_Digit}`：
```js
let regexp = /x\p{Hex_Digit}\p{Hex_Digit}/u;

alert("number: xAF".match(regexp)); // xAF
```
### 实例：中文字符
让我们再来考虑中文字符。

有一个 unicode 属性 Script （一个书写系统），这个属性可以有一个值：Cyrillic，Greek，Arabic，Han （中文）等等，[这里是一个完整的列表](https://zh.javascript.info/article/regexp-unicode/%22https://en.wikipedia.org/wiki/Script_(Unicode)%22)。

为了实现查找一个给定的书写系统中的字符，我们需要使用 `Script=<value>`，例如对于西里尔字符：`\p{sc=Cyrillic}`, 中文字符：`\p{sc=Han}`，等等。
```js
let regexp = /\p{sc=Han}/gu; // returns Chinese hieroglyphs

let str = `Hello Привет 你好 123_456`;

alert( str.match(regexp) ); // 你,好
```
### 实例：货币
表示货币的字符，例如 `$`，`€`，`¥`，具有 unicode 属性 `\p{Currency_Symbol}`，缩写为 \p{Sc}。

让我们使用这一属性来查找符合“货币，接着是一个数字”的价格文本：
```js
let regexp = /\p{Sc}\d/gu;

let  str = `Prices: $2, €1, ¥9`;

alert( str.match(regexp) ); // $2,€1,¥9
```
## 总结
修饰符 `u` 在正则表达式中提供对 Unicode 的支持。

这意味着两件事：

1. 4 个字节长的字符被以正确的方式处理：被看成单个的字符，而不是 2 个 2 字节长的字符。
2. `Unicode` 属性可以被用于查找中 `\p{…}`。
有了 unicode 属性我们可以查找给定语言中的词，特殊字符（引用，货币）等等。