# 基础知识
正则表达式是用于匹配字符串中字符组合的模式，在 JavaScript中，正则表达式也是对象。

- 正则表达式是在宿主环境下运行的，如js/php/node.js 等
- 本章讲解的知识在其他语言中知识也是可用的，会有些函数使用上的区别
## 对比分析
与普通函数操作字符串来比较，正则表达式可以写出更简洁、功能强大的代码。

下面使用获取字符串中的所有数字来比较函数与正则的差异。
```js
let hd = "houdunren2200hdcms9988";
let nums = [...hd].filter(a => !Number.isNaN(parseInt(a)));
console.log(nums.join(""));
```
使用正则表达式将简单得多
```js
let hd = "houdunren2200hdcms9988";
console.log(hd.match(/\d/g).join(""));
```
# 创建正则
JS提供字面量与对象两种方式创建正则表达式

## 字面量创建
使用`//`包裹的字面量创建方式是推荐的作法，但它不能在其中使用变量
```js
let hd = "houdunren.com";
console.log(/u/.test(hd));//true
```
下面尝试使用 a 变量时将不可以查询
```js
let hd = "houdunren.com";
let a = "u";
console.log(/a/.test(hd)); //false
```
虽然可以使用 eval 转换为js语法来实现将变量解析到正则中，但是比较麻烦，所以有变量时建议使用下面的对象创建方式
```js
let hd = "houdunren.com";
let a = "u";
console.log(eval(`/${a}/`).test(hd)); //true
```
## 对象创建
当正则需要动态创建时使用对象方式
```js
let hd = "houdunren.com";
let web = "houdunren";
let reg = new RegExp(web);
console.log(reg.test(hd)); //true
```
根据用户输入高亮显示内容，支持用户输入正则表达式
```html
<body>
  <div id="content">houdunren.com</div>
</body>
<script>
  const content = prompt("请输入要搜索的内容，支持正则表达式");
  const reg = new RegExp(content, "g");
  let body = document
    .querySelector("#content")
    .innerHTML.replace(reg, str => {
      return `<span style="color:red">${str}</span>`;
    });
  document.body.innerHTML = body;
</script>
```
通过对象创建正则提取标签
```html
<body>
  <h1>houdunren.com</h1>
  <h1>hdcms.com</h1>
</body>

<script>
function element(tag) {
  const html = document.body.innerHTML;
  let reg = new RegExp("<(" + tag + ")>.+</\\1>", "g");
  return html.match(reg);
}
console.table(element("h1"));
```
## 选择符
`|` 这个符号带表选择修释符，也就是 `|` 左右两侧有一个匹配到就可以。

检测电话是否是上海或北京的坐机
```js
let tel = "010-12345678";
//错误结果：只匹配 | 左右两边任一结果
console.log(tel.match(/010|020\-\d{7,8}/)); 

//正确结果：所以需要放在原子组中使用
console.log(tel.match(/(010|020)\-\d{7,8}/));
```
匹配字符是否包含houdunren 或 hdcms
```js
const hd = "houdunren";
console.log(/houdunren|hdcms/.test(hd)); //true
```
## 字符转义
转义用于改变字符的含义，用来对某个字符有多种语义时的处理。

假如有这样的场景，如果我们想通过正则查找`/`符号，但是` /`在正则中有特殊的意义。如果写成`///`这会造成解析错误，所以要使用转义语法 `/\//`来匹配。
```js
const url = "https://www.houdunren.com";
console.log(/https:\/\//.test(url)); //true
```
使用 `RegExp` 构建正则时在转义上会有些区别，下面是对象与字面量定义正则时区别
```js
let price = 12.23;
//含义1: . 除换行外任何字符 	含义2: .普通点
//含义1: d 字母d   					含义2: \d 数字 0~9
console.log(/\d+\.\d+/.test(price));

//字符串中 \d 与 d 是一样的，所以在 new RegExp 时\d 即为 d
console.log("\d" == "d");

//使用对象定义正则时，可以先把字符串打印一样，结果是字面量一样的定义就对了
console.log("\\d+\\.\\d+");
let reg = new RegExp("\\d+\\.\\d+");
console.log(reg.test(price));
```
下面是网址检测中转义符使用
```js
let url = "https://www.houdunren.com";
console.log(/https?:\/\/\w+\.\w+\.\w+/.test(url));
```
## 字符边界
使用字符边界符用于控制匹配内容的开始与结束约定。

| 边界符 | 说明                         |
| ------ | ---------------------------- |  |
| ^      | 匹配字符串的开始             |
| $      | 匹配字符串的结束，忽略换行符 |

匹配内容必须以www开始
```js
const hd = "www.houdunren.com";
console.log(/^www/.test(hd)); //true
```
匹配内容必须以.com结束
```js
const hd = "www.houdunren.com";
console.log(/\.com$/.test(hd)); //true
```
检测用户名长度为3~6位，且只能为字母。如果不使用 ^与$ 限制将得不到正确结果
```html
<body>
  <input type="text" name="username" />
</body>

<script>
  document
    .querySelector(`[name="username"]`)
    .addEventListener("keyup", function() {
      let res = this.value.match(/^[a-z]{3,6}$/i);
      console.log(res);
      console.log(res ? "正确" : "失败");
    });
</script>
```
# 元子字符
元字符是正则表达式中的最小元素，只代表单一（一个）字符

## 字符列表

| 元字符 | 说明                                             | 示例          |
| ------ | ------------------------------------------------ | ------------- |
| \d     | 匹配任意一个数字                                 | [0-9]         |
| \D     | 与除了数字以外的任何一个字符匹配                 | [^0-9]        |
| \w     | 与任意一个英文字母,数字或下划线匹配              | [a-zA-Z_]     |
| \W     | 除了字母,数字或下划线外与任何字符匹配            | [^a-zA-Z_]    |
| \s     | 任意一个空白字符匹配，如空格，制表符\t，换行符\n | [\n\f\r\t\v]  |
| \S     | 除了空白符外任意一个字符匹配                     | [^\n\f\r\t\v] |
| .      | 匹配除换行符外的任意字符                         |

## 使用体验
匹配任意数字
```js
let hd = "houdunren 2010";
console.log(hd.match(/\d/g)); //["2", "0", "1", "0"]
```
匹配所有电话号码
```js
let hd = `
	张三:010-99999999,李四:020-88888888
`;

let res = hd.match(/\d{3}-\d{7,8}/g);
console.log(res);
```
获取所有用户名
```js
let hd = `张三:010-99999999,李四:020-88888888`;
let res = hd.match(/[^:\d-,]+/g);
console.log(res);
```
匹配任意非数字
```js
console.log(/\D/.test(2029)); //false
```
匹配字母数字下划线
```js
let hd = "hdcms@";
console.log(hd.match(/\w/g)); //["h", "d", "c", "m", "s"]
```
匹配除了字母,数字或下划线外与任何字符匹配
```js
console.log(/\W/.test("@")); //true
```
匹配与任意一个空白字符匹配
```js
console.log(/\s/.test(" ")); //true
console.log(/\s/.test("\n")); //true
```
如果要匹配点则需要转义
```js
let hd = `houdunren@com`;
console.log(/houdunren.com/i.test(hd)); //true
console.log(/houdunren\.com/i.test(hd)); //false
```
使用`.`匹配除换行符外任意字符，下面匹配不到`hdcms.com` 因为有换行符
```js
const url = `
  https://www.houdunren.com
  hdcms.com
`;
console.log(url.match(/.+/)[0]);
```
使用`/s`视为单行模式（忽略换行）时，`.` 可以匹配所有
```js
let hd = `
  <span>
    houdunren
    hdcms
  </span>
`;
let res = hd.match(/<span>.*<\/span>/s);
console.log(res[0]);
```
正则中空格会按普通字符对待
```js
let tel = `010 - 999999`;
console.log(/\d+-\d+/.test(tel)); //false
console.log(/\d+ - \d+/.test(tel)); //true
```
## 所有字符
可以使用 `[\s\S]` 或 `[\d\D]` 来匹配所有字符
```js
let hd = `
  <span>
    houdunren
    hdcms
  </span>
`;
let res = hd.match(/<span>[\s\S]+<\/span>/);
console.log(res[0]);
```
# 模式修饰
正则表达式在执行时会按他们的默认执行方式进行，但有时候默认的处理方式总不能满足我们的需求，所以可以使用模式修正符更改默认方式。
| 修饰符 | 说明                                       |
| ------ | ------------------------------------------ |  |
| i      | 不区分大小写字母的匹配                     |
| g      | 全局搜索所有匹配内容                       |
| m      | 视为多行                                   |
| s      | 视为单行忽略换行符，使用. 可以匹配所有字符 |
| y      | 从 regexp.lastIndex 开始匹配               |
| u      | 正确处理四个字符的 UTF-16 编码             |
## i
将所有`houdunren.com` 统一为小写
```js
let hd = "houdunren.com HOUDUNREN.COM";
hd = hd.replace(/houdunren\.com/gi, "houdunren.com");
console.log(hd);
```
## g
使用 `g` 修饰符可以全局操作内容
```js
let hd = "houdunren";
hd = hd.replace(/u/, "@");
console.log(hd); //没有使用 g 修饰符是，只替换了第一个

let hd = "houdunren";
hd = hd.replace(/u/g, "@");
console.log(hd); //使用全局修饰符后替换了全部的 u
```
## m
用于将内容视为多行匹配，主要是对 `^`和 `$` 的修饰

将下面是将以 #数字开始的课程解析为对象结构，学习过后面讲到的原子组可以让代码简单些
```js
let hd = `
  #1 js,200元 #
  #2 php,300元 #
  #9 houdunren.com # 后盾人
  #3 node.js,180元 #
`;
// [{name:'js',price:'200元'}]
let lessons = hd.match(/^\s*#\d+\s+.+\s+#$/gm).map(v => {
  v = v.replace(/\s*#\d+\s*/, "").replace(/\s+#/, "");
  [name, price] = v.split(",");
  return { name, price };
});
console.log(JSON.stringify(lessons, null, 2));
```

## u
每个字符都有属性，如L属性表示是字母，P 表示标点符号，需要结合 u 模式才有效。
```js
//使用\p{L}属性匹配字母
let hd = "houdunren2010.不断发布教程，加油！";
console.log(hd.match(/\p{L}+/u));

//使用\p{P}属性匹配标点
console.log(hd.match(/\p{P}+/gu));
```
字符也有unicode文字系统属性 `Script=文字系统`，下面是使用 `\p{sc=Han}` 获取中文字符 han为中文系统，
```js
let hd = `
张三:010-99999999,李四:020-88888888`;
let res = hd.match(/\p{sc=Han}+/gu);
console.log(res);

```
使用 u 模式可以正确处理四个字符的 UTF-16 字节编码
```js
let str = "𝒳𝒴";
console.table(str.match(/[𝒳𝒴]/)); //结果为乱字符"�"
console.table(str.match(/[𝒳𝒴]/u)); //结果正确 "𝒳"
```
## lastIndex
`RegExp`对象`lastIndex` 属性可以返回或者设置正则表达式开始匹配的位置

- 必须结合 g 修饰符使用
- 对 exec 方法有效
- 匹配完成时，lastIndex 会被重置为0
```js
let hd = `后盾人不断分享视频教程，后盾人网址是 houdunren.com`;
let reg = /后盾人(.{2})/g;
reg.lastIndex = 10; //从索引10开始搜索
console.log(reg.exec(hd));
console.log(reg.lastIndex);

reg = /\p{sc=Han}/gu;
while ((res = reg.exec(hd))) {
  console.log(res[0]);
}
```
## y
我们来对比使用 y 与g 模式，使用 g 模式会一直匹配字符串
```js
let hd = "udunren";
let reg = /u/g;
console.log(reg.exec(hd));
console.log(reg.lastIndex); //3
console.log(reg.exec(hd));
console.log(reg.lastIndex); //3
console.log(reg.exec(hd)); //null
console.log(reg.lastIndex); //0
```
但使用y 模式后如果从 lastIndex 开始匹配不成功就不继续匹配了
```js
let hd = "udunren";
let reg = /u/y;
console.log(reg.exec(hd));
console.log(reg.lastIndex); //1
console.log(reg.exec(hd)); //null
console.log(reg.lastIndex); //0
```
因为使用 y 模式可以在匹配不到时停止匹配，在匹配下面字符中的qq时可以提高匹配效率
```js
let hd = `后盾人QQ群:11111111,999999999,88888888
后盾人不断分享视频教程，后盾人网址是 houdunren.com`;

let reg = /(\d+),?/y;
reg.lastIndex = 7;
while ((res = reg.exec(hd))) console.log(res[1]);
```
# 原子表
在一组字符中匹配某个元字符，在正则表达式中通过元字符表来完成，就是放到[] (方括号)中。

## 使用语法
| 原子表 | 说明                               |
| ------ | ---------------------------------- |  |
| []     | 只匹配其中的一个原子               |
| [^]    | 只匹配"除了"其中字符的任意一个原子 |
| [0-9]  | 匹配0-9任何一个数字                |
| [a-z]  | 匹配小写a-z任何一个字母            |
| [A-Z]  | 匹配大写A-Z任何一个字母            |

## 实例操作
使用`[]`匹配其中任意字符即成功，下例中匹配`ue`任何一个字符，而不会当成一个整体来对待
```js
const url = "houdunren.com";
console.log(/ue/.test(url)); //false
console.log(/[ue]/.test(url)); //true
```
日期的匹配
```js
let tel = "2022-02-23";
console.log(tel.match(/\d{4}([-\/])\d{2}\1\d{2}/));
```
获取0~3间的任意数字
```js
const num = "2";
console.log(/[0-3]/.test(num)); //true
```
匹配a~f间的任意字符
```js
const hd = "e";
console.log(/[a-f]/.test(hd)); //true
```
顺序为升序否则将报错
```js
const num = "2";
console.log(/[3-0]/.test(num)); //SyntaxError
```
字母也要升序否则也报错
```js
const hd = "houdunren.com";
console.log(/[f-a]/.test(hd)); //SyntaxError
```
获取所有用户名
```js
let hd = `张三:010-99999999,李四:020-88888888`;
let res = hd.match(/[^:\d-,]+/g);
console.log(res);
```
原子表中有些正则字符不需要转义，如果转义也是没问题的，可以理解为在原子表中`.` 就是小数点
```js
let str = "(houdunren.com)+";
console.table(str.match(/[().+]/g));

//使用转义也没有问题
console.table(str.match(/[\(\)\.\+]/g));
```
可以使用 `[\s\S]` 或 `[\d\D]` 匹配到所有字符包括换行符
```js
const reg = /[\s\S]+/g;
```
下面是使用原子表知识删除所有标题
```html
<body>
  <p>后盾人</p>
  <h1>houdunren.com</h1>
  <h2>hdcms.com</h2>
</body>
<script>
  const body = document.body;
  const reg = /<(h[1-6])>[\s\S]*<\/\1>*/g;
  let content = body.innerHTML.replace(reg, "");
  document.body.innerHTML = content;
</script>
```
# 原子组
- 如果一次要匹配多个元子，可以通过元子组完成
- 原子组与原子表的差别在于原子组一次匹配多个元子，而原子表则是匹配任意一个字符
- 元字符组用 () 包裹

下面使用原子组匹配 h1 标签，如果想匹配 h2 只需要把前面原子组改为 h2 即可。
```js
const hd = `<h1>houdunren.com</h1>`;
console.log(/<(h1)>.+<\/\1>/.test(hd)); //true
```