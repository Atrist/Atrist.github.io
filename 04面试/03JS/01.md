# JavaScript

# 同源策略
同源策略可防止 JavaScript 发起跨域请求。源被定义为协议、主机名和端口号的组合。此策略可防止页面上的恶意脚本通过该页面的文档对象模型，访问另一个网页上的敏感数据。

下表给出了与 URL http://store.company.com/dir/page.html 的源进行对比的示例:

| URL                                             | 结果 | 原因                             |
| ----------------------------------------------- | ---- | -------------------------------- |
| http://store.company.com/dir2/other.html        | 同源 | 只有路径不同                     |
| http://store.company.com/dir/inner/another.html | 同源 | 只有路径不同                     |
| https://store.company.com/secure.html           | 失败 | 协议不同                         |
| http://store.company.com:81/dir/etc.html        | 失败 | 端口不同 ( http:// 默认端口是80) |
| http://news.company.com/dir/other.html          | 失败 | 主机不同                         |

### 参考资料：

- [浏览器的同源策略](https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy)

# 跨域
- 原因
    
    浏览器的同源策略导致了跨域
- 作用
    
    用于隔离潜在恶意文件的重要安全机制
- 解决

    1. jsonp ，允许 script 加载第三方资源
    2. 反向代理（nginx 服务内部配置 Access-Control-Allow-Origin *）
    3. cors 前后端协作设置请求头部，Access-Control-Allow-Origin 等头部信息
    4. iframe 嵌套通讯，postmessage

### 参考资料：

- [新鲜出炉的8月前端面试题](https://zhuanlan.zhihu.com/p/41479807)
- [跨域资源共享 CORS 阮一峰](http://www.ruanyifeng.com/blog/2016/04/cors.html)

# JSONP
这是我认为写得比较通俗易懂的一篇文章[jsonp原理详解——终于搞清楚jsonp是啥了](https://blog.csdn.net/hansexploration/article/details/80314948)。

# 域名收敛
PC 时代为了突破浏览器的域名并发限制，有了域名发散。浏览器有并发限制，是为了防止DDOS攻击。

**域名收敛**：就是将静态资源放在一个域名下。减少DNS解析的开销。

**域名发散**：是将静态资源放在多个子域名下，就可以多线程下载，提高并行度，使客户端加载静态资源更加迅速。

域名发散是pc端为了利用浏览器的多线程并行下载能力。而域名收敛多用与移动端，提高性能，因为dns解析是是从后向前迭代解析，如果域名过多性能会下降，增加DNS的解析开销。

# 事件绑定的方式
- 嵌入dom

    ```html
    <button onclick="func()">按钮</button>
    ```
- 直接绑定

    ```js
    btn.onclick = function(){}
    ```
- 事件监听

    ```js
    btn.addEventListener('click',function(){})
    ```
# 事件委托
事件委托利用了事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。所有用到按钮的事件（多数鼠标事件和键盘事件）都适合采用事件委托技术， 使用事件委托可以节省内存。
```html
<ul>
  <li>苹果</li>
  <li>香蕉</li>
  <li>凤梨</li>
</ul>

<script>
// good
document.querySelector('ul').onclick = (event) => {
  let target = event.target
  if (target.nodeName === 'LI') {
    console.log(target.innerHTML)
  }
}

// bad
document.querySelectorAll('li').forEach((e) => {
  e.onclick = function() {
    console.log(this.innerHTML)
  }
}) 
</script>
```
# 事件循环
事件循环是一个单线程循环，用于监视调用堆栈并检查是否有工作即将在任务队列中完成。如果调用堆栈为空并且任务队列中有回调函数，则将回调函数出队并推送到调用堆栈中执行。
# 事件模型
## DOM0
直接绑定
```html
<input onclick="sayHi()"/>

<script>
btn.onclick = function() {}
btn.onclick = null
</script>
```
## DOM2
- DOM2级事件可以冒泡和捕获
- 通过addEventListener绑定
- 通过removeEventListener解绑

```js
// 绑定
btn.addEventListener('click', sayHi)
// 解绑
btn.removeEventListener('click', sayHi)
```

## DOM3

- DOM3具有更多事件类型
- DOM3级事件在DOM2级事件的基础上添加了更多的事件类型，全部类型如下：

```bash
UI事件，当用户与页面上的元素交互时触发，如：load、scroll
焦点事件，当元素获得或失去焦点时触发，如：blur、focus
鼠标事件，当用户通过鼠标在页面执行操作时触发如：dbclick、mouseup
滚轮事件，当使用鼠标滚轮或类似设备时触发，如：mousewheel
文本事件，当在文档中输入文本时触发，如：textInput
键盘事件，当用户通过键盘在页面上执行操作时触发，如：keydown、keypress
合成事件，当为IME（输入法编辑器）输入字符时触发，如：compositionstart
变动事件，当底层DOM结构发生变化时触发，如：DOMsubtreeModified
```
### 参考资料：

- [dom0、dom2、dom3事件](https://www.jianshu.com/p/3acdf5f71d5b)

# 如何自定义事件
## 新模式

```js
const div = document.createElement('div') // 不创建元素，直接用 window 对象也可以
const event = new Event('build')

div.addEventListener('build', function(e) {
    console.log(111)
})

div.dispatchEvent(event)
```
## 过时的模式
原生提供了3个方法实现自定义事件
1. `document.createEvent('Event')` 创建事件
2. `initEvent` 初始化事件
3. `dispatchEvent` 触发事件

```js
const events = {}

function registerEvent(name) {
    const event = document.createEvent('Event')
    event.initEvent(name, true, true) // 事件名称，是否允许冒泡，该事件的默认动作是否可以被取消
    events[name] = event
}

function triggerEvent(name) {
    window.dispatchEvent(events[name])
}

registerEvent('resize') // 注册 resize 事件
triggerEvent('resize') // 触发 resize 事件
```
[MDN](https://developer.mozilla.org/zh-CN/docs/Web/Guide/Events/Creating_and_triggering_events)

# target和currentTarget区别
- event.target
  - 返回触发事件的元素
- event.currentTarget
  - 返回绑定事件的元素

# prototype和`__proto__`的关系是什么
先说结论：
1. `prototype` 用于访问函数的原型对象。
2. `__proto__` 用于访问对象实例的原型对象（或者使用 `Object.getPrototypeOf()`）

```js
function Test() {}
const test = new Test()
test.__proto__ == Test.prototype // true
```
也就是说，函数拥有 `prototype` 属性，对象实例拥有 `__proto__` 属性，它们都是用来访问原型对象的。

函数有点特别，它不仅是个函数，还是个对象。所以它也有 `__proto__` 属性。