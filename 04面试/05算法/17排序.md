## 知道的排序算法 说一下冒泡快排的原理
冒泡排序: 重复地走访过排序地元素列, 依次比较两个相邻地元素,如果他们的顺序(如从大到小,首字母从A到Z)错误就把他们交换过来. 走访元素的工作是重复地进行直到没有相邻元素需要交换, 也就是说该元素已经排序完成.

快速排序: 通过一趟排序将要排序地数据分割成独立地两部分,其中一部分的所有数据都比另外一部分的所有数据都要小,然后再按此方法对这部分数据分别进行快速排序,整个排序过程递归进行,依次达到整个数据变成有序序列

## Heap排序方法的原理? 复杂度?
堆排序（英语：Heapsort）是指利用[堆](https://baike.baidu.com/item/%E5%A0%86)这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。

复杂度：O(nlgn)

## 几种常见的排序算法,手写
基本排序算法: 冒泡, 选择, 插入, 希尔, 归并, 快排

冒泡排序
```js
function bubbleSort(data){
    let temp = 0;
    for(let i=data.length;i>0;i--){
        for(let j=0;j<i-1;j++){
            if(data[j] > data[j+1]){
                temp = data[j];
                data[j] = data[j+1];
                data[j+1] = temp;
            }
        }
    }
    return data;
}
```
选择排序

```js
function selectionSort(data){
    for(let i =0;i<data.length;i++){
        let main = data[i];
        let temp;
        let index=1;
        for(let j = i+1;j<date.length;j++){
            if(data[j]<min){
                temp = data[j];
                data[j] = min;
                data[index] = temp;

            }
        }
    }
    return data;

}
```
插入排序
```js
function insertSort(data){
    let len = data.length;
    for(let i=0;i<len;i++){
        let key = data[i];
        let j = i-1;
        while(j >= 0 && data[j] > key){
            data[j+1] = data[i];
            j--;
        }
        data[j+1] = key;
    }
    return data;
}
```
希尔排序
```js
function shallSort(array){
    let increment = array.length;
    let i ;
    let temp; // 暂存
    do{
        // 设置增量
        increment = Math.floor(increment / 3) + 1;
        for(i = increment;i<array.length;i++){
            temp = array [i];
            for(var j = i- increment;j>= 0 && temp<array[j];j -= increment){
                array[j+increment] = array[j];
            }
        }
    }while(increment > 1)
    return array;
}
```
归并排序
```js
function mergeSort(array){
    let len = array.length;
    if(len <2){
        return array;
    }

    let middle = Math.floor(len/2);
    let left = array.slice(0,middle);
    let right = array.slice(middle);
    return merge(mergeSort(left),mergeSort(right));
}

function merge(left,right){
    let result = [];
    while(left.length && right.length){
        if(left[0] <= right[0]>){
            result.push(left.shit());
        }else{
            result.push(right.shift());
        }
    }
    while(left.length) result.push(left.shift());
    while(right.length) result.push(right.shift());
    return result;
}
```
快速排序
```js
function quickSort(arr){
    if(arr.length === 0){
        return [];
    }
    let left = [];
    let right = [];
    let pivot = arr[0];

    for(let  i=0;i<arr.length;i++>){
        if(arr[i]< pivot){
            left.push(arr[i]);
        }
        else{
            right.push(arr[i]);
        }
    }
    return quickSort(left).concat(pivot,quickSort(right));

}
```

## 数组的去重, 尽可能写出多个方法

1. 最简单的双层循环方法
    ```js
    let array = ['1', '2', 1, '1', '4', '9', '1'];

    function unique(array) {
        let res = [];
        let resLen;
        let j;
        let arrayLen;
        let i;
        for (i = 0, arrayLen = array.length; i < array.length; i++) {
            for (j = 0, resLen = array.length; j < array.length; j++) {
                if (array[i] == res[j]) break;
            }
            if (j === resLen) {
                res.push(array[i]);
            }
        }
        return res;
    }

    console.log(unique(array))
    ```

2. 用indexOf简化内层循环: indexOf函数返回某个指定的字符在字符串中第一次出现的位置

    ```js
    let array = ['1', '2', 1, '1', '4', '9', '1'];
    function unique(array){
        let res = [];
        for(let i=0;i<array.length;i++){
            let current =array[i];
            if(res.indexOf(current) === -1){
                res.push(current);
            }
        }
        return res;
    }
    console.log(unique(array));
    ```

3. 排序后去重

    ```js
    var array = ['1', '2', 1, '1', '4', '9', '1'];

    function unique(array) {
        // res用来存储结果
        let res = [];
        let sortArray = array.concat().sort();
        console.log(sortArray);
        let seen;
        for (let i = 0, len = sortArray.length; i < len; i++) {
            if (!i || seen !== sortArray[i]) {
                res.push(sortArray[i]);
            }
            seen = sortArray[i];
        }
        return res;
    }
    console.log(unique(array));
    ```

4. ES6的方法，使用set和map数据结构，以set为例，它类似于数组，但是成员的值都是唯一的，没有重复的值，很适合这个题目

    ```js
    let array = ['1', '2', 1, '1', '4', '4', '1'];

    function unique(array) {
        // res用来存储结果

        return Array.from(new Set(array));
    }
    console.log(unique(array));
    ```
    或者更简化点
    ```js
    let array = ['1', '2', 1, '1', '4', '4', '1'];

    function unique(array) {
        // res用来存储结果

        return [...new Set(array)];
    }
    console.log(unique(array));
    ```

##  如果有一个大的数组，都是整型，怎么找出最大的前10个数
排序数组，输出前10个

##  找出数组中第k大的数组出现多少次，比如数组【1，2，4，4，3，5】第二大的数字是4，出现两次，所以返回2
对数组进行排序，找到第k大的数，然后看第k大的数有几个，返回

## 给一个数，去一个已经排好序的数组中寻找这个数的位置（通过快速查找，二分查找）
```js
function binarySearch(target, arr, start, end) {
    let start = start || 0;
    let end = end || arr.length - 1;
    let mid = parseInt(start + (end - start) / 2);
    if (target == arr[mid]) {
        return mid;
    } else if (target > arr[mid]) {
        return binarySearch(target, arr, mid + 1, end);
    } else {
        return binarySearch(target, arr, start, mid - 1);
    }
}
```