## 说一下css盒模型
就是用来装页面上的元素的矩形区域, css中的盒子包括IE盒子和标准的W3C盒子模型

box-sizing: border-box, padding-box, content-box

标准盒子模型:

![](./images/42498021-b4dd6a46-845d-11e8-8bd9-ac2d90985f2a.png)

IE盒子模型:

![](./images/42498075-d3496e3a-845d-11e8-919c-eb3a7866883b.png)

区别: 从图中我们可以看出, 这两种盒子模型主要的区别就是width的包含范围,在标准的盒子模型中,width指content部分的宽度, 在IE盒子模型中, width表示content + padding + border 这三个部分的宽度, 故这使得在计算整个盒子的宽度时存在这差异:

标准盒子模型的盒子宽度: 左右border + 左右padding + width

IE盒子模型: width

在css3中引入了`box-sizing`属性, `box-sizing:content-box`; 表示标准的盒子模型,`box-sizing:border-box` 表示的IE盒子模型, 最后,前面我们还提到了,box-sizing:padding-box,这个属性值的宽度包含了padding + width


## 画一条0.5px的线
1. 采用meta viewport的方式
    ```html
    <meta name="viewport" content="initial-scale=1.0,maximum-scale=1.0,user-scalable=no">
    ```
2. 采用border-image 的方式
3. 采用transform:scale()的方式

## link标签和import标签的区别
- link属于html标签,而@import时css提供的
- 页面加载时,link会同时被加载,而@import引用的css会等到页面加载结束后加载
- link是html标签,因为没有兼容性,而@import只有ie5以上才有识别
- link方式样式的权重高于@import的

## transition和animation的区别
Animation和transition大部分属性是相同的, 他们都是随时间改变元素的属性值,他们的主要区别是transition需要触发一个事件才能改变属性, 而animation不需要触发任何事件的情况下才会随时间改变属性值,并且transition为2帧,从from....to,而animation可以一帧一帧的

## flex布局
文章链接:
- http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?utm_source=tuicool%EF%BC%88%E8%AF%AD%E6%B3%95%E7%AF%87%EF%BC%89
- http://www.ruanyifeng.com/blog/2015/07/flex-examples.html

flex是flexible Box的缩写, 意为"弹性布局",用来为盒状模型提供最大的灵活性

布局的传统解决方案,基于盒状模型, 依赖 display属性 + position属性 + float属性, 它对于那些特殊布局非常不方便,比如,垂直居中就不容易是西安


简单的分为容器属性和元素属性

### 容器属性:

flex-direction: 决定主轴的方向(即子item的排列方法)
```css
.box{
    flex-direction: row| row-reverse| column| column-reverse;
}
```

flex-wrap: 决定换行规则
```css
.box{
    flex-wrap: nowrap|wrap|wrap-reverse
}
```
flex-flow: 
```css
.box{
    flex-flow: <flex-direction > | <flex-wrap>
}
```
justify-content: 对齐方式, 水平主轴对齐方式

align-items: 对齐方式,竖直轴线方向

### 项目的属性(元素的属性)
- order属性: 定义项目的排列顺序,顺序越小,排列越靠前,默认为0
- flex-grow属性: 定义项目的放大比例,即使存在空间,也不会放大
- flex-shrink属性: 定义了项目的缩小比例,当空间不足的情况下会等比例的缩小,如果定义个item的flow-shrink为0, 则为不缩小
- flex-basis属性: 定义了在分配多余的空间,项目占据的空间
- flex: 是flex-grow和flex-shrink,flex-basis的简写, 默认值为0 1 auto
- algin-self: 允许单个项目与其他项目不一样的对齐方式,可以覆盖align-items,默认属性为auto, 表示继承父元素的algin-items

## BFC(块级格式化上下文, 用于清除浮动, 防止margin重叠等)
直译成: 块级格式化上下文,是一个独立的渲染区域, 并且有一定的布局规则

- BFC区域不会与float box 重叠
- BFC是页面上的一个独立容器, 子元素不会影响到外面
- 计算BFC的高度时, 浮动元素也会参与计算

那些元素会生成BFC
- 根元素`html`
- `float` 不为 none 的元素
- `position`为 fixed 和 absolute 的元素
- display为 inline-block,table-cell, table-caption, flex, inline-flex等
- overflow 不为 visible 等

## 垂直居中的方法
1. margin:auto方法

    ```css
    div{
        width:100%;
        height:100%;
        position:relative;
        border:1px solid #465468;
    }
    img{
        position:absolute;
        margin: auto;
        top:0;
        left:0;
        right:0;
        bottom:0;
    }
    ```
    html
    ```html
    <div>
        <img src="nm.jpg">
    </div>
    ```
    定位为上下左右为0, margin:auto 可以实现脱离文档流的居中

2. margin负值法

    ```css
    .container{
        width: 500px;
        height:400px;
        border:2px solid #379;
    }
    .inner{
        width:480px;
        height:380px;
        background-color: #746;
        position: absolute;
        top:50%;
        left:50%;
        margin-top:-190px;  /* height的一半 */
        margin-left: -240px; /* width的一半 */
    }
    ```
    补充: 其实这里也可以讲margin-to和margin-left替换成 transform:translateX(-50%)和transform:translateY(-50%);

3. table-cell (未脱离文档流的)

    设置父元素的`display:table-cell`,并且`vertical-algin:middle`,这样子元素可以实现垂直居中
    ```css
    div{
        width:300px;
        height:300px;
        border:3px solid #555;
        display:table-cell;
        vertical-align:middle;
        text-align:center;
    }
    img{
        vertical-align:middle;
    }
    ```
4. 利用 flex

    将父元素设置为`display:flex`,并且设置`algin-items:center`; `justify-content:center`;
    ```css
    .container{
        width:300px;
        height:200px;
        border:3px solid #546461;
        display: flex;
        display: -webkit-flex;
        -webkit-algin-items: center;
        align-items: center;
        -webkit-justify-content: center;
        justify-content:center;
    }
    .inner{
        border:3px solid #458761;
        padding:20px;
    }
    ```

## 关于js动画和css3动画的差异性
渲染线程分为`main thread`和`compositor thread`, 如果css动画只改变transform和opacity,这时整个css动画得以在`compositor thread`完成(而js动画则会在`main thread`执行, 然后触发`compositor thread`进行下一步操作),特别注意的是如果改变`transform`和`opacity`是不会layout或者paint的(需要元素提升为合成层)

区别:
- 功能涵盖面,js比css大
- 实现/重构难度不一,css3比js更加简单,性能调优方向固定
- 对帧速表现不好的低版本浏览器, css3可以做到自然降级
- css3动画有天然事件支持
- css3有兼容性问题


##  说一下块元素和行元素
- 块元素:独占一行, 并且有自动填满元素,可以设置margin和padding以及高度和宽度
- 行元素:不会独占一行,`width`和`height`会失效,并且在垂直方向的padding和margin会失效

## 多行元素的文本省略号

```css
display: -webkit-box;
-webkit-box-orient:vertical
-webkit-line-clamp:3
overflow:hidden
```
## visibility=hidden, opacity=0, display:none
- opacity=0,该元素隐藏起来了,但不会改变页面布局,并且,如果该元素已经绑定一些事件, 如click事件,那么点击该区域,也能触发点击事件的
- visibility=hidden, 该元素隐藏起来了,但不会改变页面布局, 但是不会触发该元素已经绑定的事件
- display:none, 把元素隐藏起来,并且会改变页面布局,可以理解成在页面中把该元素删除掉一样

## 双边距重叠问题
多个相邻(兄弟或者父子关系)普通流的块元素垂直方向margin会重叠

重叠的结果为:
- 两个相邻的外边据都是正数时,折叠结果是它们两者之间较大的值
- 两个相邻的外边距都是负数时,折叠结果是两者绝对值的较大值
- 两个外边距一正一负时,折叠结果是两者的相加的和

## position属性比较
- 固定定位fixed: 元素的位置相对于浏览器窗口是固定位置,即使窗口是滚动的它也不会移动. Fixed定位使元素的位置与文档流无关,因此不占据空间. Fixed定位的元素和其他元素重叠

- 相对定位relative: 如果对一个元素进行相对定位, 它将出现在它所在的位置上,然后,可以通过设置垂直或水平位置,让这个元素"相对于'它的起点进行移动, 在使用相对定位时, 无论是否进行移动,元素仍然占据原来的空间,因此,移动元素会导致它覆盖其他框

- 粘性定位sticky: 元素先按照普通文档流定位,然后相对于该元素在这流中的flow root(BFC) 和 containing block(最近的块级祖先元素)定位. 而后,元素定位表现为在跨越特定阈值前为相对定位, 之后为固定定位
- 默认定位 static: 默认值,没有定位, 元素出现在正常的六种(忽略to,bottom,left,right或者z-index 声明)
- inherit: 规定应该从父元素继承position属性的值

## 浮动清除
1. 使用带clear属性的空元素
   
   在浮动元素后使用一个空元素如`<div class="clear"></div>`, 并在css中赋予`.clear { clear:both ;}`属性即可清理浮动, 亦可使用`<br class="clear" />`或`<hr class="clear" />`来进行清理

2. 使用css的overflow属性

    给浮动元素的容器添加`overflow:hidden;`或`overflow:auto;`可以清除浮动, 另外在IE6中还需要触发 `hasLayout`, 例如为父元素设置容器宽高或设置`zoom:1`
3. 给浮动元素的容器添加浮动

    给浮动元素的容器也添加上浮动属性即可清除内部浮动,但是这样会使其整体浮动,影响布局,不推荐使用
4. 使用邻接元素处理

    什么都不做,给浮动元素后面的元素添加 `clear`属性
5. 使用css的`::after`伪元素
    
    结合`::after`伪元素和IE hack,可以完美兼容当前主流的各大浏览器,这里的IE hack指的是触发`hasLayout`,给浮动元素的容器添加一个`clearfix`的class,然后给这个class添加一个`::after`实现元素末尾添加一个看不见的块元素(Block element)清理浮动


## css选择器有哪些, 优先级呢?
id选择器, class选择器,标签选择器,伪元素/伪类选择器等

优先级:
- 同一元素引用了多个样式时, 排在后面的样式属性的优先级高
- 样式选择器的类型不同时, 优先级顺序为:id 选择器 > class 选择器>标签选择器
- 标签之间存在层级包含关系时, 后代元素会继承祖先元素的样式, 如果后代元素定义了与祖先元素相同的样式, 则祖先元素的相同的样式属性会被覆盖, 继承的样式的优先级比较低, 至少比标签选择器的优先级低
- 带有`!important`标记的样式属性的优先级最高
- 样式表的来源不同,优先级顺序为 : 内联样式 > 内部样式 > 外部样式 > 浏览器用户自定义样式 > 浏览器默认样式

## css动画如何实现
创建动画序列, 需要使用animation属性 或 其子属性, 该属性允许配置动画时间,时长以及其他动画细节, 但该属性不能配置动画的实际表现, 动画的实际表现是由@keyframes规则实现, 具体情况参见使用 keyframes 定义动画序列小节部分

`transition`也可以实现动画, `transition`强调过渡, 是元素的一个或多个属性发生变化时产生的过渡效果, 同一个元素通过两个不同的途径获取样式, 而第二个途径当某种改变发生(例如hover)时才能获取样式, 这样就会产生过渡动画

## float的元素,display是什么

display: block

## 三栏布局的实现方式, 尽可能多写, 浮动布局时, 三个div的生成顺序有没有影响

三列布局又分为两种, 两列定宽一列自适应, 以及两侧定宽中间自适应

两列定宽一列自适应:
1. 使用float + margin:

    给div设置`float:left`, `left`的`div`添加属性 margin-right: `left 和center的间隔`px,right的div添加属性margin-left: `left和center 的宽度之和加上间隔`px

2. 使用float + overflow

    给div设置float:left, 再给right的div设置overflow:hidden, 这样子两个盒子浮动,另一个盒子触发`bfc`达到自适应

3. 使用position

    父级div设置`position: relative`, 三个子级div设置`position: absolute`, 这个要计算好盒子的宽度和间隔去设置位置,兼容性比较好

4. 使用table实现

    父级div设置`position:table`, 设置`border-spacing:10px // 设置间距, 取值随意`,子级div设置`display:table-cell`,这种方法兼容性好, 适用于高度宽度未知的情况, 但是margin失效, 设计间隔比较麻烦

5. flex实现

    parent的div设置`display:flex`; left和center的`div`设置`margin-right;` 然后right的div设置 `flex:1`; 这样子`right`自适应,但`flex`的兼容性不好

6. grid实现:

    parent的div设置`display:grid`, 设置 grid-template-columns属性,固定第一列第二列宽度,第三列auto

对于两侧定宽中间自适应的布局,对于这种布局需要把center放在前面,可以采用双飞翼布局, 圣杯布局来实现,也可以使用上述方法中的grid,table,flex,position实现


## calc属性

calc用户动态计算长度值, 任何长度值都可以使用calc()函数计算, 需要注意的是, 运算符前后都需要保留一个空格, 例如 `width:calc(100% - 10px)`

## z-index的定位方法

`z-index`属性设置元素的堆叠顺序, 拥有更好堆叠顺序的元素会处于较低顺序元素之前, `z-index`可以为负,且`z-index`只能在定位元素上凑效, 该属性设置一个定位元素沿z轴的位置,如果为正数,离用户越近,为负数,离用户越远, 它的属性值由auto, 默认, 堆叠顺序与父元素相等, `number`,`inherit`,从父元素继承`z-index`属性的值