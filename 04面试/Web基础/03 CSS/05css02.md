
## 如果想要改变一个DOM元素的字体颜色,不在它本身上进行操作/

可以更改父元素的color

## line-height 和 height的区别
line-height 一般是指布局里面一段文字上下行之间的高度,是针对字体来设置的, height一般是指容器的整体高度

## 设置一个元素的背景颜色,背景颜色会填充哪些区域
background-color: 设置的背景颜色会填充元素的content, padding, border区域

## 知道属性选择器和伪类选择的优先级吗?
属性选择器和伪类选择器优先级相同

## inline-block, inline和block的区别; 为什么img是inline还是可以设置宽高?

- Block是块级元素,其前后都会有换行符, 能设置宽度,高度, `margin/padding`水平垂直方向都有效
- inline: 设置width和height无效, margin在竖直方向上无效,padding在水平垂直方向都有效, 前后无换行符
- inline-block: 能设置宽度高度, margin/padding水平垂直方向都有有效, 前后换行符

## 用css实现一个硬币旋转的效果
虽然不认为很多人能在面试中写出来
```css
#euro{
    width:150px;
    height:150px;
    margin-left:-75px;
    margin-top:-75px;
    position:absolute;
    top:50%;
    left:50%;
    transform-style:preserve-3d;
    animation: spin 2.5s linear infinite;

}
.back{
    background-image: url('backEuro.png');
    width:150px;
    height:150px;
}
.middle{
    background-image: url('faceEuro.png');
    width:150px;
    height:150px;
    transform:translateZ(1px);
    position:absolute;
    top:0;
    
}
.front{
    background-image: url('faceEuro.png');
    width:150px;
    height:150px;
    transform:translateZ(10px);
    position:absolute;
    top:0;
}

@keyframes spin{
    0%{
        transform: rotateY(0deg);
    }
    100%{
        transform: rotateY(360deg);
    }
}
```

## 了解重绘和重排吗,知道怎么去减少重绘和重拍吗, 让文档流脱离文档流有哪些方法

DOM的变化影响到了元素的几何属性比如(宽,高),浏览器重新计算元素的几何属性,其他元素的几何属性也会受到影响, 浏览器需要重新构造渲染树, 这个过程称之为重排, 浏览器将会受到影响的部分重新绘制在屏幕上的过程称为重绘, 引起重排重绘的原因有:
  - 添加或者删除可见的DOM元素
  - 元素尺寸位置的改变
  - 浏览器页面初始化
  - 浏览器窗口大小发生改变, 重排一定导致重绘, 重绘不一定导致重排
  
减少重绘重排的方法有:
- 不在布局信息改变时做DOM查询
- 使用csstext, className一次性改变属性
- 使用fragment
- 对于多次重排的元素,比如说动画, 使用绝对定位脱离文档流,使其不影响其他元素

## css画正方体,三角形
画三角形
```css
#triangle02{
    width:0;
    height:0;
    height:0;
    border-top:50px solid blue;
    border-bottom:50px solid green;
    border-left:50px solid yellow;
}
```
画正方体
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title> perspective</title>
    <style>
    .wrapper{
        width:50%;
        float:left;
    }
    .cube{
        font-size:4em;
        width:2em;
        transform-style: preserve-3d;
        transform:rotateX(-35deg) rotateY(30deg);
    }
    .side{
        position: absolute;
        width:2em;
        height:2em;
        background: rgba(255,99,71,0.6);
        color:white;
        text-align:center;
        line-height:2em;
    }
    .front{
        transform:translateZ(1em);
    }
    .bottom{
        transform:rotateX(-90deg) translateZ(1em);
    }
    .top{
        transform:rotateX(90deg) translateZ(1em);
    }
    .left{
        transform:rotateY(-90deg) translateZ(1em);
    }
    .right{
        transform:rotateY(90deg) translateZ(1em);
    }
    .back{
        transform:translateZ(-1em);
    }
    </style>
</head>

<body>
    <div class="wrapper w1">
    <div class="cube">
        <div class="side front">1</div>
        <div class="side back">6</div>
        <div class="side right">4</div>
        <div class="side left">3</div>
        <div class="side top">5</div>
        <div class="side bottom">2</div>
    </div>
    </div>

        <div class="wrapper w2">
    <div class="cube">
        <div class="side front">1</div>
        <div class="side back">6</div>
        <div class="side right">4</div>
        <div class="side left">3</div>
        <div class="side top">5</div>
        <div class="side bottom">2</div>
    </div>
    </div>
</body>

</html>
```

## overflow的原理
要讲清楚这个解决方案的原理, 首先需要了解格式化上下文,`A block formatting context is a part of a visual css rendering of a web page. It is the region in which the layout of blocks boxes occurs and in which floats interact with each other.` 翻译过来就是 块格式上下文是CSS可视化渲染的一部分, 它是一块区域, 规定了内部块盒的渲染方式, 以及浮动相互之间的影响关系

当元素设置了`overflow` 样式且值不为`visible`时, 该元素就构建了一个BFC, BFC在计算高度时,内部浮动元素的高度也要计算在内, 也就是说即使BFC区域内只有一个浮动元素, BFC的高度也不会发生塌缩,所以达到了清楚浮动的目的

## box-sizing的语法和基本用处
`box-sizing`规定两个并排的带边框的框, 语法为`box-sizing: content-box/border-box/inherit`

- `content-box`: 宽度和高度分别应用到元素的内容框, 在宽度和高度之外绘制元素的内边框和边框
- `border-box`:为元素设定的宽度和高度决定了元素的边框盒
- `inherit`: 继承父元素的`box-sizing`

## 两个嵌套的div,position都是absolute,子div设置top属性, 那么这个top时相对于服父元素的哪个位置定位的.
margin 的外边缘

## 说说盒子模型
css盒模型本质上是一个盒子, 封装周围的HTML元素,它包括: 边距, 边框,填充,和实际内容

标准盒模型: 一个块的总宽度  =   width + margin(左右) + padding(左右) + border(左右)

怪异盒模型: 一个块的总宽度  = width + margin(左右) (既width已经包含了padding 和 border值)

## css布局
六种布局方式总结: 圣杯布局,双飞翼布局,Flex布局,绝对定位布局, 表格布局, 网格布局

- 圣杯布局: 是指布局从上到下分为 header, container, footer, 然后 container部分定位三栏布局, 这种布局方式同样分为 header, container, footer, 圣杯布局的缺陷在于`center`是在container的padding中的,因此宽度小的时候会出现混乱
- 双飞翼布局给`center`部分包裹了一个`main`通过设置`margin`主动地把页面撑开
- flex布局是由css3提供地一种方便的布局方式
- 绝对定位布局是给container设置`position:relative`和`overflow:hidden`, 因为绝对定位的元素的参照物为第一个position不为static的祖先元素, left向左浮动, right向右浮动, center使用绝对定位, 通过设置`left`和`right`并把两边撑开. center 设置 `top:0` 和 `bottom: 0` 使其高度撑开
- 表格布局的好处是能使三栏的高度统一
- 网格布局可能是最强大的布局方式了,使用起来及其方便,但目前而言,兼容性并不好. 网格布局,可以将页面分割成多个区域,或者用来定义内部元素的大小,位置,图层关系

